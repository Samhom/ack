# JVM 内存分代

​	系统的地址空间 可以划分为 内核空间 和用户空间。内核空间主要是系统运行空间，包含连接系统硬件和调度程序以及提供联网和虚拟内存等服务 C 进程运行空间，而用户空间是 Java 程序实际运行时所在内存空间。

## 1、内存模型

​	JVM 架构图中，类加载器（Class Loader）负责依据特定格式，加载class文件到内存；执行引擎（Execution Engine）负责对命令进行解析；本地库接口（Native Interface） 负责融合不同开发语言的原生库为Java所用。

​	运行时数据区包括：方法区、堆、虚拟机栈、本地方法栈、程序计数器，其中后三者为线程私有内存、前两者属于线程共享内存。

### 程序计数器

- （1）程序计数器  当前线程所执行的字节码行号指示器（逻辑）
- （2）CPU 改变计数器的值来选取下一条需要执行的字节码指令
- （3）和线程是一对一的关系即“线程私有”
- （4）对 java 方法计数，如果是 Native 方法则计数器值为 Undefined
- （5）不会发生内存泄漏

### 虚拟机栈

- （1）虚拟机栈 Java 方法执行的内存模型
- （2）虚拟机栈包含多个栈帧，其中每个方法执行都会创建一个栈帧并放入虚拟机栈，当方法执行完后再将该栈帧移除。
- （3）一个栈帧包括局部变量表、操作栈、动态连接、返回地址等
- （4）虚拟机栈有大小限制，当超出最大栈深度后，会发生SOF异常

虚拟机栈 OutOfMemmoryError 异常场景：

Xss 参数是设定虚拟机中每个线程占用的栈内存大小，而虚拟机栈可分配的内存又跟物理机的内存大小、Java堆内存、方法区等内存大小相关，其它的区分得的内存越大，虚拟机栈能够分得的内存就越小，并发的线程数量也就越小；

而如果要想模拟 OOM 异常可以通过不停的创建线程，直到虚拟机栈内存被使用完。

### 本地方法栈

与虚拟机栈相似，主要作用是标注了Native的方法。

### 方法区

​	方法区是 JVM 的一种规范，保存 java 类的相关信息(包括 Method、Filed 等）。 元空间 和永久代 都是方法区的实现。

永久代（PermGen）：

​	jdk8 之前，使用永久代，但是从 jdk 7 开始，原先位于永久代中的字符串常量池被移入到堆内存中。

元空间相对永久代具有如下优势：

- （1）字符串常量池存在永久代中，容易出现性能问题和内存溢出
- （2）类和方法的信息大小难以确定，给永久代的大小指定困难
- （3）永久代会为 GC 带来不必要的复杂度
- （4）方便 HotSpot 与其他 JVM 如 Jrockit 的集成

### Java 堆

虚拟机启动时创建，被所有线程共享，是对象实例的分配区域。同时也是 GC 管理的主要区域。

java 内存模型中 堆 和 栈 的联系和区别

联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址
区别：

- 1，管理方式：栈自动释放，堆需要 GC
- 2，空间大小：栈比堆小
- 3，碎片化： 栈产生的碎片远小于堆
- 4，分配方式： 栈支持静态和动态分配，而堆只支持动态分配
- 5，效率：栈的效率比堆高

## 3、几种常量池

在 Java 的内存分配中，总共3种常量池：

### 字符串常量池(String Constant Pool):

- 在 JDK6.0 及之前版本，字符串常量池是放在 Perm Gen 区(也就是方法区)中；
- 在 JDK7.0 版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。
- 在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable 类，它是一个Hash表，默认值大小长度是1009；这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了 StringTable 上。StringTable 的长度可以通过参数指定：-XX:StringTableSize=10000（默认是1009）
- String Pool 里放的是字符串常量和放于堆内的字符串对象的引用。字符串常量池中的字符串只存在一份！

### class 常量池 (Class Constant Pool)：

​	我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)；每个 class 文件都有一个 class 常量池。

字面量包括：

- 1.文本字符串 
- 2.八种基本类型的值 
- 3.被声明为final的常量等

符号引用包括：

- 1.类和方法的全限定名 
- 2.字段的名称和描述符 
- 3.方法的名称和描述符

### 运行时常量池(Runtime Constant Pool)：

​	运行时常量池存在于内存中，也就是 class 常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern())，符号引用可以被解析为直接引用。

​	JVM 在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm 就会将 class 常量池中的内容存放到运行时常量池中。

​	由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的 StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

## eden 和survivor 区比例为什么是8:1：

​	因为经过统计，每次 Young GC 会有 90% 的对象被回收，所以要预留空间去保存剩下的 10%。

## 元空间和方法区

​	永久代和元空间都是方法区的实现。

​	但是从 Java7 开始，原先位于永久代中的字符串常量池被移入到堆内存中。

​	在 Java7 以及之前堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。但在物理上来说，它们又是连续的一块内存，如下图：

![img](https://user-gold-cdn.xitu.io/2019/12/14/16f04be2bed541ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

​	对于 Java8，HotSpots 取消了永久代，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于**本地内存（Native memory），不在虚拟机中**。java7 和 java8 堆和方法区实现两者之间的逻辑示意图如下：

​	![img](https://user-gold-cdn.xitu.io/2019/12/14/16f04cbeba65c4fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

针对 Java8 的调整，内存结构图如下：

![img](https://user-gold-cdn.xitu.io/2019/12/14/16f04cdf3a0ba3ea?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



​	默认情况下元空间是可以无限使用本地内存的，但为了不让它如此膨胀，JVM 同样提供了参数来限制它使用的使用：

-**XX:MetaspaceSize**，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。

-**XX：MaxMetaspaceSize**，可以为class metadata分配的最大空间。默认是没有限制的。

-**XX：MinMetaspaceFreeRatio**，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。

-**XX:MaxMetaspaceFreeRatio**，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。

## 永久代的弊端：

​	在 java7 及以前的永久代中，存放了包含虚拟机中所有可通过反射获取到 Class 和 Meta 的信息，JVM 运行时会用到多少持久代的空间取决于应用程序用到了多少类，所以如果 APP LOAD 很多 CLASS 的话，就很可能出现 PermGen space 错误。并且永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。

## 元空间存储内容：

​	元空间里面保存的是类的元数据，如方法、字段、类、包的描述信息，不过有点要提的是 A.class 其实是存在 heap 里的，是 java.lang.Class 的一个对象实例。

## 元空间的特点：

- 充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。
-  每个加载器有专门的存储空间
-  只进行线性分配
-  不会单独回收某个类
-  省掉了GC扫描及压缩的时间
-  元空间里的对象的位置是固定的
-  如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉

## 元空间相对永久代具有如下优势：

- 字符串常量池存在永久代中，容易出现性能问题和内存溢出
- 类和方法的信息大小难以确定，给永久代的大小指定困难
- 永久代会为 GC 带来不必要的复杂度
- 方便 HotSpot 与其他 JVM 如 Jrockit 的集成

## JVM 配置参数参考

```shell
-Xmx4096m 
-XX:-OmitStackTraceInFastThrow 
-Xss256k 
-Xms4096m 
-XX:MetaspaceSize=128m 
-XX:MaxMetaspaceSize=256m 
-XX:+UseG1GC 
-XX:MaxGCPauseMillis=200
-XX:+PrintGCDetails 
-Xloggc:/opt/logs/10723/gc-1592279812.log 
-XX:HeapDumpPath=/opt/logs/10723 
-XX:+PrintGC 
-XX:+HeapDumpOnOutOfMemoryError 
-XX:+PrintGCDateStamps
```
