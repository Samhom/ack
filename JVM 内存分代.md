### JVM 内存分代

​	系统的地址空间 可以划分为 内核空间 和用户空间。内核空间主要是系统运行空间，包含连接系统硬件和调度程序以及提供联网和虚拟内存等服务 C 进程运行空间，而用户空间是 Java 程序实际运行时所在内存空间。

#### 1、内存模型

​	JVM 架构图中，类加载器（Class Loader）负责依据特定格式，加载class文件到内存；执行引擎（Execution Engine）负责对命令进行解析；本地库接口（Native Interface） 负责融合不同开发语言的原生库为Java所用。

​	运行时数据区包括：方法区、堆、虚拟机栈、本地方法栈、程序计数器，其中后三者为线程私有内存、前两者属于线程共享内存。

##### 程序计数器

- （1）程序计数器  当前线程所执行的字节码行号指示器（逻辑）
- （2）CPU 改变计数器的值来选取下一条需要执行的字节码指令
- （3）和线程是一对一的关系即“线程私有”
- （4）对 java 方法计数，如果是 Native 方法则计数器值为 Undefined
- （5）不会发生内存泄漏

##### 虚拟机栈

- （1）虚拟机栈 Java 方法执行的内存模型
- （2）虚拟机栈包含多个栈帧，其中每个方法执行都会创建一个栈帧并放入虚拟机栈，当方法执行完后再将该栈帧移除。
- （3）一个栈帧包括局部变量表、操作栈、动态连接、返回地址等
- （4）虚拟机栈有大小限制，当超出最大栈深度后，会发生SOF异常

虚拟机栈 OutOfMemmoryError 异常场景：

Xss 参数是设定虚拟机中每个线程占用的栈内存大小，而虚拟机栈可分配的内存又跟物理机的内存大小、Java堆内存、方法区等内存大小相关，其它的区分得的内存越大，虚拟机栈能够分得的内存就越小，并发的线程数量也就越小；

而如果要想模拟 OOM 异常可以通过不停的创建线程，直到虚拟机栈内存被使用完。

##### 本地方法栈

与虚拟机栈相似，主要作用是标注了Native的方法。

##### 方法区

​	方法区是 JVM 的一种规范，保存 java 类的相关信息(包括 Method、Filed 等）。 元空间 和永久代 都是方法区的实现。

永久代（PermGen）：

jdk8之前，使用永久代。永久代使用的是 JVM 内存。 但是从 jdk 7 开始，原先位于永久代中的字符串常量池被移入到堆内存中。

元空间（MetaSpace）：
jdk8 开始使用元空间替代永久代。元空间使用堆内存。

元空间相对永久代具有如下优势：

- （1）字符串常量池存在永久代中，容易出现性能问题和内存溢出
- （2）类和方法的信息大小难以确定，给永久代的大小指定困难
- （3）永久代会为 GC 带来不必要的复杂度
- （4）方便 HotSpot 与其他 JVM 如 Jrockit 的集成

##### Java 堆

虚拟机启动时创建，被所有线程共享，是对象实例的分配区域。同时也是 GC 管理的主要区域。

java 内存模型中 堆 和 栈 的联系和区别

联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址
区别：

- 1，管理方式：栈自动释放，堆需要 GC
- 2，空间大小：栈比堆小
- 3，碎片化： 栈产生的碎片远小于堆
- 4，分配方式： 栈支持静态和动态分配，而堆只支持动态分配
- 5，效率：栈的效率比堆高

#### 2、intern()

​	当调用 intern() 方法时，如果字符串常量池先前已创建出该字符串常量，则返回池中的该字符串的引用。否则，如果该字符串对象已经存在Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用。

#### 3、几种常量池

在 Java 的内存分配中，总共3种常量池：

##### 字符串常量池(String Constant Pool):

- 在 JDK6.0 及之前版本，字符串常量池是放在 Perm Gen 区(也就是方法区)中；
- 在 JDK7.0 版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。
- 在 HotSpot VM 里实现的 string pool 功能的是一个 StringTable 类，它是一个Hash表，默认值大小长度是1009；这个 StringTable 在每个 HotSpot VM 的实例只有一份，被所有的类共享。字符串常量由一个一个字符组成，放在了 StringTable 上。StringTable 的长度可以通过参数指定：-XX:StringTableSize=10000（默认是1009）
- String Pool 里放的是字符串常量和放于堆内的字符串对象的引用。字符串常量池中的字符串只存在一份！

##### class 常量池 (Class Constant Pool)：

​	我们写的每一个Java类被编译后，就会形成一份class文件；class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)；每个 class 文件都有一个 class 常量池。

字面量包括：

- 1.文本字符串 
- 2.八种基本类型的值 
- 3.被声明为final的常量等

符号引用包括：

- 1.类和方法的全限定名 
- 2.字段的名称和描述符 
- 3.方法的名称和描述符

##### 运行时常量池(Runtime Constant Pool)：

​	运行时常量池存在于内存中，也就是 class 常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加(String#intern())，符号引用可以被解析为直接引用。

​	JVM 在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm 就会将 class 常量池中的内容存放到运行时常量池中。

​	由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的 StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。

#### 4、Java 8 的内存分代改进

##### 先阐述先方法区的实现—持久代的特点及其局限性：

持久代（也叫永久代）是 HotSpot 的概念，指内存的永久保存区域。

说说为什么会内存益出：

这一部分用于存放 Class 和 Meta 的信息，Class 在被 Load 的时候被放入 PermGen space 区域，它和和存放 Instance 的 Heap 区域不同，所以如果你的 APP 会 LOAD 很多 CLASS 的话，就很可能出现 PermGen space 错误。

持久代中包含了虚拟机中所有可通过反射获取到的数据，比如 Class 和 Method 对象。

JVM 用于描述应用程序中用到的类和方法的元数据也存储在持久代中。JVM 运行时会用到多少持久代的空间取决于应用程序用到了多少类。除此之外，Java SE 库中的类和方法也都存储在这里。

如果 JVM 发现有的类已经不再需要了，它会去回收（卸载）这些类，将它们的空间释放出来给其它类使用。Full GC会进行持久代的回收。

持久代的大小：它的上限是 MaxPermSize ，默认是64M。

需要多大的持久代空间取决于类的数量，方法的大小，以及常量池的大小。

##### 为什么移除持久代：

- 它的大小是在启动时固定好的——很难进行调优。-XX:PermSize 和 -XX:MaxPermSize 来指定最小值和最大值。HotSpot 的内部类型也是 Java 对象：它可能会在 Full GC中 被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。
- 简化 Full GC：每一个回收器有专门的元数据迭代器。可以在GC不进行暂停的情况下并发地释放类数据。

根据上面的各种原因，永久代最终被移除，方法区移至 Metaspace ，字符串常量移至 Java Heap。

移除持久代后，这部分内存空间将全部移除。JVM 的参数：PermSize 和 MaxPermSize 会被忽略并给出警告（如果在启用时设置了这两个参数）。

##### 元空间（MetaSpace 也是本地内存（Native memory））：

​	JDK 8 的 HotSpot JVM 现在使用的是本地内存来表示类的元数据，这个区域就叫做元空间。

​	在 JDK1.8 中，永久代已经不存在，存储的类信息、编译后的代码数据等已经移动到了 MetaSpace（元空间）中，元空间并没有处于堆内存上。这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace) (运行常量池在直接内存元空间中，字符串常量池在堆中)。

​	元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小： 

- -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 
- -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 
- -verbose 参数是为了获取类型加载和卸载的信息。

元空间由 Klass Metaspace 和 NoKlass Metaspace 组成。

##### Klass Metaspace:

Klass Metaspace 就是用来存 klass 的，klass 是我们熟知的 class 文件在 jvm 里的运行时数据结构，不过有点要提的是我们看到的类似 A.class 其实是存在 heap 里的，是 java.lang.Class 的一个对象实例。这块内存是紧接着Heap的，和我们之前的 perm 一样，这块内存大小可通过 -XX:CompressedClassSpaceSize 参数来控制，这个参数前面提到了默认是1G。

##### NoKlass Metaspace:

​	NoKlass Metaspace 专门来存 klass 相关的其他的内容，比如 method，constantPool 等，这块内存是由多块内存组合起来的，所以可以认为是不连续的内存块组成的。这块内存是必须的，虽然叫做 NoKlass Metaspace，但是也其实可以存 klass 的内容。

​	Klass Metaspace 和 NoKlass Mestaspace 都是所有 classloader 共享的，所以类加载器们要分配内存，但是每个类加载器都有一个SpaceManager，来管理属于这个类加载的内存小块。如果 Klass Metaspace 用完了，那就会 OOM 了，不过一般情况下不会，NoKlass Mestaspace 是由一块块内存慢慢组合起来的，在没有达到限制条件的情况下，会不断加长这条链，让它可以持续工作。

##### 元空间的特点：

- ​	充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。
- ​	每个加载器有专门的存储空间
- ​	只进行线性分配
- ​	不会单独回收某个类
- ​	省掉了GC扫描及压缩的时间
- ​	元空间里的对象的位置是固定的
- ​	如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉

##### 元空间的内存分配模型：

- ​	绝大多数的类元数据的空间都从本地内存中分配
- ​	用来描述类元数据的类(klasses)也被删除了
- ​	分元数据分配了多个虚拟内存空间
- ​	给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型； sun/反射/代理对应的类加载器的块会小一些
- ​	归还内存块，释放内存块列表
- ​	一旦元空间的数据被清空了，虚拟内存的空间会被回收掉
- ​	减少碎片的策略			

#### eden 和survivor 区比例为什么是8:1：
			
  因为经过统计，每次 Young GC 会有 90% 的对象被回收，所以要预留空间去保存剩下的10%。
