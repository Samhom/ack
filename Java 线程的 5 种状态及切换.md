# Java 线程的 5 种状态及切换

### Java 中的线程的生命周期大体可分为 5 种状态

1. #### 新建(NEW)：

   新创建了一个线程对象，并没有调用start()方法之前。

2. #### 可运行(RUNNABLE)：

   ​	也就是就绪状态，调用start()方法之后线程就进入就绪状态， 但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态。线程对象创建后，其他线程(比如 main 线程）调用了该对象的 start() 方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取 cpu 的使用权 。

3. #### 运行(RUNNING)：

   ​	可运行状态(runnable)的线程获得了 cpu 时间片（timeslice） ，执行程序代码。：线程被设置为当前线程，开始执行 run() 方法。就是线程进入运行状态

4. #### 阻塞(BLOCKED)：

   ​	阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。线程被暂停，比如说调用 sleep() 方法后线程就进入阻塞状态。 

   阻塞的情况分三种： 

   ##### (一) 等待阻塞：

   ​	运行(running)的线程执行 o.wait() 方法，JVM 会把该线程放入等待队列 (waitting queue)中。

   ##### (二). 同步阻塞：

   ​	运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。

   ##### (三). 其他阻塞：

   ​	运行(running)的线程执行 Thread.sleep(long ms) 或 t.join() 方法，或者发出了I/O请求时，JVM 会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5. #### 死亡(DEAD)：

   ​	线程执行结束，线程 run()、main() 方法执行结束，或者因异常退出了 run()方法，则该线程结束生命周期。死亡的线程不可再次复生。