# gc roots

​	Java 对象并不是只有用户才能 new，虚拟机内部也 new 了一些，只要从某个地方出发能发现存活对象，它们就是 GC Root。GC 会收集那些不是 GC roots 且没有被 GC roots 引用的对象。

## 一、按照类型来分，作为 GC Roots 对象的包括如下几种：	

1. 虚拟机栈(栈桢中的本地变量表)中的引用的对象
2. 本地方法栈中 JNI 的引用的对象
3. 方法区中（全局）的类静态属性引用的对象
4. 方法区中（全局）的常量引用的对象

## 二、以上的这些种类包括的可以是以下这些：

### 1、由系统类加载器(system class loader)加载的对象

​	这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的 java.lang.Class 实例以其它的某种（或多种）方式成为 roots，否则它们并不是 roots。

### 2、活着的线程

### 3、Java 方法的 local 变量或参数

### 4、JNI 方法的 local 变量或参数

### 5、全局 JNI 引用

### 6、用于同步的监控对象

### 7、用于 JVM 特殊目的由 GC 保留的对象

​	但实际上这个与 JVM 的实现是有关的。可能已知的一些类型是：系统类加载器、一些 JVM 知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM 并没有为这些对象提供其它的信息，因此需要去确定哪些是属于" JVM 持有"的了。

### 三、来自官网的介绍

| 类型                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| System Class 类型     | 由引导程序/系统类加载器加载的类型。例如，rt.jar中的所有内容（如java.util。*）。 |
| JNI Local 类型        | 本机原生代码中的局部变量，例如用户定义的JNI代码或JVM内部代码。 |
| JNI Global 类型       | 本机原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。 |
| Thread Block 类型     | 从当前活动的线程块引用的对象。                               |
| Thread 类型           | 已经启动运行的线程 thread.                                   |
| Busy Monitor 类型     | 忙碌的监视器代码，调用了wait（）或notify（）或已同步的所有代码。 |
| Java Local 类型       | 局部变量。例如，输入参数或仍在线程堆栈中的方法的局部创建对象。 |
| Native Stack 类型     | 本机原生代码中的输入或输出参数，例如用户定义的JNI代码或JVM内部代码。 |
| Finalizable 类型      | 可终结对象，队列中等待其终结器运行的对象.                    |
| Unfinalized 类型      | 未终结对象，具有finalize方法但尚未完成且尚未在终结器队列中的对象. |
| Unreachable 类型      | 不可达对象，无法从任何其他根访问的对象，MAT使用.             |
| Java Stack Frame 类型 | Java栈框架，持有局部变量。解析Dump时使用.                    |
| Unknown 类型          | 根类型未知对象。MAT分析Dump文件时的特殊类型，归类不可知类型. |

