## 一次完整的 GC 流程&对象如何晋升到老年代

##### Java 8 整个的JVM堆内存之中实际上将内存分为了三块：

- 年轻代：新对象和没达到一定年龄的对象都在年轻代；
- 老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大；
- 元空间：像一些方法中的操作临时对象等，直接使用物理内存；

​	对于整个的 GC 流程里面，那么最需要处理的就是年轻代与老年代的内存清理操作，而元空间（永久代）不在 GC 范围内；

### 1、Java 垃圾对象判断的标准

​	当虚拟机发现该对象没有被其他对象引用时，则将该对象判断为可以回收的垃圾对象。检测对象是否为被其他对象引用可以使用**引用计数法**和**可达性分析算法**。

##### 引用计数法

执行效率高，程序执行受影响较小，无法检测出 循环引用的情况，导致内存泄漏。

##### 可达性分析算法（通过判断对象的引用链是否可达来决定对象是否可以被回收）

可以作为 GC root 的对象：

- （1）虚拟机栈中引用的对象（栈帧中的本地变量表）
- （2）方法区中的常量引用的对象
- （3）方法区中的类静态属性引用的对象
- （4）本地方法栈中JNI(Native方法）的引用对象
- （5）活跃线程的引用对象

### 2、内存分配策略流程

- ##### a.当现在有一个新的对象产生，那么对象一定需要内存空间，于是现在就需要为该对象进行内存空间的申请；

  大对象直接进入老年代 ，JVM提供了一个对象大小阈值参数 (-XX:PretenureSizeThreshold，默认值为0，代表不管多大都是先在 Eden 中分配内存)，大于参数设置的阈值值的对象直接在老年代分配，这样可以避免对象在 Eden 及两个 Survivor 直接发生大内存复制。

- ##### b.首先会判断伊甸园区是否有内存空间，如果此时有内存空间，则直接将新对象保存在伊甸园区；

- ##### c.但是如果此时伊甸园区的内存空间不足，那么会自动执行一个 Minor GC 操作，将伊甸园区的无用内存空间进行清理，清理之后会继续判断伊甸园区的内存空间是否充足？如果内存空间充足，则将新的对象直接在伊甸园区进行空间分配；

- ##### d.如果执行了 Minor GC 之后发现伊甸园区的内存依然不足，那么这个时候会进行存活区判断，如果存活区有剩余空间，则将伊甸园区的部分活跃对象保存在存活区，那么随后继续判断伊甸园区的内存空间是否充足，如果充足，则在伊甸园区进行新对象的空间分配；

  注意：当前的 Survivor 区满时，此区的存活且不满足晋升到老年代条件的对象将被复制到另外一个 Survivor 区。对象每经历一次复制，年龄加1，达到晋升年龄阈值后，转移到老年代

- ##### e.如果此时存活区也已经没有内存空间了，则继续判断老年区，如果此时老年区空间充足，则将存活区中的活跃对象保存到老年代，随后伊甸园区将活跃对象保存在存活区之中，而后在伊甸园区里为新对象开辟空间；

- ##### f.如果这个时候老年代也满了，那么这个时候将产生 Major GC（Full GC），进行老年代的内存清理。

- ##### g.如果老年代执行了 Full GC 之后发现依然无法进行对象的保存，就会产生 OOM 异常“OutOfMemoryError”。

#### 空间分配担保

​	当进行 Young GC 之前，也就是在上述的步骤 c 中 Minor GC 操作之前，JVM 需要预估老年代是否能够容纳 Young GC 后新生代晋升到老年代的存活对象，以确定是否需要提前触发 GC 回收老年代空间。

基于空间分配担保策略来计算（continueSize：老年代最大可用连续空间）：

- continueSize 是否大于新生代所有对象总空间，yes 则执行 Young GC
- no 的话继续判断 continueSize 是否大于平均晋升到老年代对象的平均大小，no 则执行 Full GC
  yes 则执行 Young GC
- 继续判断 continueSize 是否大于需晋升到老年代的对象大小， no 则担保失败，接着执行 Full GC
  YES 则担保成功，空间分配担保流程结束

#### 动态年龄判定

​	新生代对象的年龄可能没达到阈值( MaxTenuringThreshold 参数指定)就晋升老年代，如果 Young GC 之后，新生代存活对象达到相同年龄所有对象大小的总和大于任一 Survivor 空间(S0 或 S1总空间)的一半，此时S0或者S1区即将容纳不了存活的新生代对象，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold 中要求的年龄。

​	另外，如果 Young GC 后 S0 或 S1 区不足以容纳未达到晋升老年代条件的新生代存活对象，会导致这些存活对象直接进入老年代，需要尽量避免。

#### Minor Gc 触发条件

​			如上所述。
​			另外：Minor Gc （又叫 Young GC） 每次都会引起全线停顿(Stop-The-World)，暂停所有的应用线程，停顿时间相对老年代GC的造成的停顿，几乎可以忽略不计

#### Major Gc 触发条件

​			Major GC，只清理老年代空间的GC事件，只有CMS的并发收集是这个模式 Full GC，清理整个堆的GC事件，包括新生代、老年代、元空间等，Mixed GC，清理整个新生代以及部分老年代的GC，只有G1有这个模式。