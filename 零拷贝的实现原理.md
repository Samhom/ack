### 零拷贝的实现原理

#### 从一个文件中读出数据并将数据传到另一台服务器上流程图：

![img](https://upload-images.jianshu.io/upload_images/2184951-730b2ba2fb35256a.png?imageMogr2/auto-orient/strip|imageView2/2/w/898/format/webp)

#### 这种方式一共涉及了 4 次数据拷贝：

1. 应用程序中调用 read() 方法，这里会涉及到一次**上下文切换（用户态->内核态）**，底层采用 DMA（direct memory access）读取磁盘的文件，并把内容存储到内核地址空间的读取缓存区。
2. 由于应用程序无法读取内核地址空间的数据，如果应用程序要操作这些数据，必须把这些内容从读取缓冲区拷贝到用户缓冲区。这个时候，read()  调用返回，且引发一次**上下文切换（内核态->用户态）**，现在数据已经被拷贝到了用户地址空间缓冲区，这时，如果有需要，应用程序可以操作修改这些内容。
3. 我们最终目的是把这个文件内容通过 Socket 传到另一个服务中，调用 Socket 的 send() 方法，这里又涉及到一次**上下文切换（用户态->内核态）**，同时，文件内容被进行第三次拷贝，被再次拷贝到内核地址空间缓冲区，但是这次的缓冲区与目标套接字相关联，与读取缓冲区没有半点关系。
4. send()  调用返回，引发第四次的**上下文切换**，同时进行第四次的数据拷贝，通过 DMA 把数据从目标套接字相关的缓存区传到协议引擎进行发送。

在整个过程中，过程1和4是由DMA负责，并不会消耗CPU，只有过程2和3的拷贝需要CPU参与。
硬件和软件之间的数据传输可以通过使用 DMA 来进行，DMA 进行数据传输的过程中几乎不需要 CPU 参与。

#### 优化一：内核态缓存冲区数据直接拷贝到套接字相关的缓存区

​	如果在应用程序中，不需要操作内容，过程 2 和 3 就是多余的，如果可以直接把内核态读取缓存冲区数据直接拷贝到套接字相关的缓存区，即可以达到优化的目的。

![img](https://upload-images.jianshu.io/upload_images/2184951-21458487f46d6201.png?imageMogr2/auto-orient/strip|imageView2/2/w/990/format/webp)

- 上下文切换的次数从四次减少到了两次。
- 数据拷贝次数从四次减少到了三次（其中DMA copy 2次，CPU copy 1次）。

虽然性能有所改善，但还没达到零拷贝的要求。

##### 实现方式

​	在 Java 中，正好 FileChannel 的 transferTo() 方法可以实现这个过程，该方法将数据从文件通道传输到给定的可写字节通道， file.read() 和  socket.send() 调用动作可以替换为 transferTo() 调用。在 UNIX 和各种 Linux 系统中，此调用被传递到  sendfile()  系统调用中，最终实现将数据从一个文件描述符传输到了另一个文件描述符。

```Java
public void transferTo(long position, long count, WritableByteChannel target);
```

#### 优化二、

​	如果底层网络接口卡支持收集操作的话，就可以进一步的优化，Linux 针对套接字缓冲区描述符做了相应调整，DMA 自带了收集功能，对于用户方面，用法还是一样的，但是内部操作已经发生了改变：

![img](https://upload-images.jianshu.io/upload_images/2184951-0e7ff381221f976d.png?imageMogr2/auto-orient/strip|imageView2/2/w/906/format/webp)

- transferTo() 方法引发 DMA 将文件内容拷贝到内核读取缓冲区。
- 把包含数据位置和长度信息的描述符追加到套接字缓冲区，避免了内容整体的拷贝，DMA 引擎直接把数据从内核缓冲区传到协议引擎，从而消除了最后一次 CPU参与的拷贝动作。

#### Linux 中的零拷贝技术主要有下面这几种：

​	直接 I/O：

对于这种数据传输方式来说，应用程序可以直接访问硬件存储，操作系统内核只是辅助数据传输：这类零拷贝技术针对的是操作系统内核并不需要对数据进行直接处理的情况，数据可以在应用程序地址空间的缓冲区和磁盘之间直接进行传输，完全不需要 Linux 操作系统内核提供的页缓存的支持。

​	在数据传输的过程中，避免数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间进行拷贝：

有的时候，应用程序在数据进行传输的过程中不需要对数据进行访问，那么，将数据从 Linux 的页缓存拷贝到用户进程的缓冲区中就可以完全避免，传输的数据在页缓存中就可以得到处理。在某些特殊的情况下，这种零拷贝技术可以获得较好的性能。Linux 中提供类似的系统调用主要有 mmap()，sendfile() 以及 splice()。

​	对数据在 Linux 的页缓存和用户进程的缓冲区之间的传输过程进行优化：

该零拷贝技术侧重于灵活地处理数据在用户进程的缓冲区和操作系统的页缓存之间的拷贝操作。这种方法延续了传统的通信方式，但是更加灵活。在Linux中，该方法主要利用了写时复制技术。
