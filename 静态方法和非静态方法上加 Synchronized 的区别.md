## 静态方法和非静态方法上加 Synchronized 的区别

- Synchronzied 修饰非静态方法——**对象锁**
- Synchronzied 修饰静态方法——**类锁**，因为是静态方法，它把整个类锁起来了；

### 一、synchronized 修饰非静态方法，

##### 实际上是对调用该方法的对象加锁，俗称“对象锁”。 

#### 情况 1：同一个对象在两个线程中分别访问该对象的两个同步方法

结果：会产生互斥。

解释：因为锁针对的是对象，当对象调用一个 synchronized 方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。 

#### 情况 2：不同对象在两个线程中调用同一个同步方法

结果：不会产生互斥。

解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是 new 一个对象，那么就会出现两个空间，两把钥匙。

### 二、Synchronized 

##### 修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。

#### 情况 1：用类直接在两个线程中调用两个不同的同步方法

结果：会产生互斥。

解释：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有 N 个房间，一把锁，因此房间（同步方法）之间一定是互斥的。

注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。 

#### 情况 2：用一个类的静态对象在两个线程中调用静态方法或非静态方法

结果：会产生互斥。

解释：因为是一个对象调用，同上。

####  情况 3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法

结果：不会产生互斥。

解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。