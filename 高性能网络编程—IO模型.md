## 高性能网络编程—I/O模型

### **1、典型互联网服务端处理网络请求的典型过程**

​	![img](https://pic4.zhimg.com/80/v2-287185d879a1e7ecd7cd24a30f01803b_hd.jpg)

**由上图可以看到，主要处理步骤包括：**

- 获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）；

- 构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）；

- 返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端（5-7）。

**设计服务端并发模型时，主要有如下两个关键点：**

- 服务器如何管理连接，获取输入数据；

- 服务器如何处理请求。

  

### 2、“I/O 模型”的基本认识

**介绍操作系统的 I/O 模型之前，先了解一下几个概念：**

**<u>什么是I/O：</u>**

​	所谓的**I/O 就是计算机内存与外部设备之间拷贝数据的过程**。我们知道 CPU 访问内存的速度远远高于外部设备，因此 CPU 是先把外部设备的数据读到内存里，然后再进行处理。请考虑一下这个场景，当你的程序通过 CPU 向外部设备发出一个读指令时，数据从外部设备拷贝到内存往往需要一段时间，这个时候 CPU 没事干了，你的程序是主动把 CPU 让给别人？还是让 CPU 不停地查：数据到了吗，数据到了吗……这就是 I/O 模型要解决的问题。



**<u>阻塞与非阻塞：</u>**

1. 阻塞调用与非阻塞调用；

2. 阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；

3. 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

   两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。

   **阻塞**是指调用方一直在等待而且别的事情什么都不做；**非阻塞**是指调用方先去忙别的事情。



**<u>同步与异步：</u>**

1. 同步处理是指被调用方得到最终结果之后才返回给调用方；

2. 异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方。

   

<u>**阻塞、非阻塞和同步、异步的区别**（**阻塞、非阻塞和同步、异步其实针对的对象是不一样的）：**</u>

1. 阻塞、非阻塞的讨论对象是调用者；
2. 同步、异步的讨论对象是被调用者；



<u>**recvfrom 函数：**</u>

recvfrom 函数(经 Socket 接收数据)，这里把它视为系统调用。



**<u>一个输入（当用户线程发起 I/O 操作后），网络数据读取操作通常包括两个不同的阶段</u>：**

1. 等待数据准备好，也就是用户线程等待内核将数据从网卡拷贝到内核空间；
2. 从内核向进程复制数据，也就是内核将数据从内核空间拷贝到用户空；

对于一个网络 I/O 通信过程，比如网络数据读取，会涉及两个对象，一个是调用这个 I/O 操作的用户线程，另外一个就是操作系统内核。一个进程的地址空间分为用户空间和内核空间，用户线程不能直接访问内核空间。

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

实际应用程序在系统调用完成上面的 2 步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时，处理方式的同步、异步处理的不同，可以分为 5 种 I/O 模型。



### 3、5种I/O模型

#### 阻塞式 I/O 模型(blocking I/O）

![img](https://pic1.zhimg.com/80/v2-02327aad1e357023d04871bc8dbd7ad0_hd.jpg)

用户线程发起 read 调用后就阻塞了，让出 CPU。内核等待网卡数据到来，把数据从网卡拷贝到内核空间，接着把数据拷贝到用户空间，再把用户线程叫醒。

**映射到系统调用层面：**

在阻塞式 I/O 模型中，应用程序在从调用 recvfrom 开始到它返回有数据报准备好这段时间是阻塞的，recvfrom 返回成功后，应用进程开始处理数据报。

**比喻：**一个人在钓鱼，当没鱼上钩时，就坐在岸边一直等。

**优点：**程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。

**缺点：**每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大，这种模型在实际生产中很少使用。



#### 非阻塞式 I/O 模型(non-blocking I/O）

![img](https://pic2.zhimg.com/80/v2-b12eca79d4e35ac9fd19debec34b1b85_hd.jpg)

用户线程不断的发起 read 调用，数据没到内核空间时，每次都返回失败，直到数据到了内核空间，这一次 read 调用后，在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的，等数据到了用户空间再把线程叫醒。

**映射到系统调用层面：**

在非阻塞式 I/O 模型中，应用程序把一个套接口设置为非阻塞，就是告诉内核，当所请求的 I/O 操作无法完成时，不要将进程睡眠。

而是返回一个错误，应用程序基于 I/O 操作函数将不断的轮询数据是否已经准备好，如果没有准备好，继续轮询，直到数据准备好为止。

**比喻：**边钓鱼边玩手机，隔会再看看有没有鱼上钩，有的话就迅速拉杆。

**优点：**不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好。

**缺点：**轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I/O 模型。



#### I/O 复用模型(I/O multiplexing）

![img](https://pic4.zhimg.com/80/v2-640b2fabcdfa626df16306b2fcaf6597_hd.jpg)

用户线程的读取操作分成两步了，线程先发起 select 调用，目的是问内核数据准备好了吗？等内核把数据准备好了，用户线程再发起 read 调用。在等待数据从内核空间拷贝到用户空间这段时间里，线程还是阻塞的。那为什么叫 I/O 多路复用呢？因为一次 select 调用可以向内核查多个数据通道（Channel）的状态，所以叫多路复用。

**映射到系统调用层面：**

在 I/O 复用模型中，会用到 Select 或 Poll 函数或 Epoll 函数(Linux 2.6 以后的内核开始支持)，这两个函数也会使进程阻塞，但是和阻塞 I/O 有所不同。

这两个函数可以同时阻塞多个 I/O 操作，而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。

**比喻：**放了一堆鱼竿，在岸边一直守着这堆鱼竿，没鱼上钩就玩手机。

**优点：**可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。

**缺点：**当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。

众所周之，Nginx这样的高性能互联网反向代理服务器大获成功的关键就是得益于Epoll。



#### 信号驱动式 I/O 模型（signal-driven I/O)

![img](https://pic3.zhimg.com/80/v2-83358c35b518def37f6563430e4d0e26_hd.jpg)

在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并安装一个信号处理函数，进程继续运行并不阻塞。

当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。

**比喻：**鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机。

**优点：**线程并没有在等待数据时被阻塞，可以提高资源的利用率。

**缺点：**信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。

信号驱动 I/O 尽管对于处理 UDP 套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。

但是，对于 TCP 而言，信号驱动的 I/O 方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失。



#### 异步 I/O 模型（即AIO，全称asynchronous I/O）

![img](https://pic1.zhimg.com/80/v2-970781650ff4d39c6b0b3beb13649330_hd.jpg)

用户线程发起 read 调用的同时注册一个回调函数，read 立即返回，等内核将数据准备好后，再调用指定的回调函数完成处理。在这个过程中，用户线程一直没有阻塞。

**映射到系统调用层面：**

由 POSIX 规范定义，应用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。

这种模型与信号驱动模型的主要区别在于：信号驱动 I/O 是由内核通知应用程序何时启动一个 I/O 操作，而异步 I/O 模型是由内核通知应用程序 I/O 操作何时完成。

**优点：**异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠。

**缺点：**要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O。

而在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 IO 复用模型模式为主。



### 4、5 种 I/O 模型比较

![img](https://pic3.zhimg.com/80/v2-59224b90b60105a38b74de84e277254e_hd.jpg)

从上图中我们可以看出，越往后，阻塞越少，理论上效率也是最优。

这五种 I/O 模型中，前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。